// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: file_whisper.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_file_5fwhisper_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_file_5fwhisper_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_file_5fwhisper_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_file_5fwhisper_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_file_5fwhisper_2eproto;
namespace whisper {
class Data;
struct DataDefaultTypeInternal;
extern DataDefaultTypeInternal _Data_default_instance_;
class File;
struct FileDefaultTypeInternal;
extern FileDefaultTypeInternal _File_default_instance_;
class Meta;
struct MetaDefaultTypeInternal;
extern MetaDefaultTypeInternal _Meta_default_instance_;
class Meta_MapBoolEntry_DoNotUse;
struct Meta_MapBoolEntry_DoNotUseDefaultTypeInternal;
extern Meta_MapBoolEntry_DoNotUseDefaultTypeInternal _Meta_MapBoolEntry_DoNotUse_default_instance_;
class Meta_MapNumberEntry_DoNotUse;
struct Meta_MapNumberEntry_DoNotUseDefaultTypeInternal;
extern Meta_MapNumberEntry_DoNotUseDefaultTypeInternal _Meta_MapNumberEntry_DoNotUse_default_instance_;
class Meta_MapStringEntry_DoNotUse;
struct Meta_MapStringEntry_DoNotUseDefaultTypeInternal;
extern Meta_MapStringEntry_DoNotUseDefaultTypeInternal _Meta_MapStringEntry_DoNotUse_default_instance_;
class Node;
struct NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class WhisperReply;
struct WhisperReplyDefaultTypeInternal;
extern WhisperReplyDefaultTypeInternal _WhisperReply_default_instance_;
class WhisperRequest;
struct WhisperRequestDefaultTypeInternal;
extern WhisperRequestDefaultTypeInternal _WhisperRequest_default_instance_;
}  // namespace whisper
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace whisper {

// ===================================================================


// -------------------------------------------------------------------

class WhisperRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:whisper.WhisperRequest) */ {
 public:
  inline WhisperRequest() : WhisperRequest(nullptr) {}
  ~WhisperRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WhisperRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline WhisperRequest(const WhisperRequest& from) : WhisperRequest(nullptr, from) {}
  inline WhisperRequest(WhisperRequest&& from) noexcept
      : WhisperRequest(nullptr, std::move(from)) {}
  inline WhisperRequest& operator=(const WhisperRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WhisperRequest& operator=(WhisperRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WhisperRequest& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kFilePath = 1,
    kFileContent = 2,
    DATA_NOT_SET = 0,
  };
  static inline const WhisperRequest* internal_default_instance() {
    return reinterpret_cast<const WhisperRequest*>(
        &_WhisperRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(WhisperRequest& a, WhisperRequest& b) { a.Swap(&b); }
  inline void Swap(WhisperRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WhisperRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WhisperRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<WhisperRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WhisperRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WhisperRequest& from) { WhisperRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WhisperRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "whisper.WhisperRequest"; }

 protected:
  explicit WhisperRequest(::google::protobuf::Arena* arena);
  WhisperRequest(::google::protobuf::Arena* arena, const WhisperRequest& from);
  WhisperRequest(::google::protobuf::Arena* arena, WhisperRequest&& from) noexcept
      : WhisperRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPasswordsFieldNumber = 3,
    kFilePathFieldNumber = 1,
    kFileContentFieldNumber = 2,
  };
  // repeated string passwords = 3;
  int passwords_size() const;
  private:
  int _internal_passwords_size() const;

  public:
  void clear_passwords() ;
  const std::string& passwords(int index) const;
  std::string* mutable_passwords(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_passwords(int index, Arg_&& value, Args_... args);
  std::string* add_passwords();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_passwords(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& passwords() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_passwords();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_passwords() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_passwords();

  public:
  // string file_path = 1;
  bool has_file_path() const;
  void clear_file_path() ;
  const std::string& file_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_file_path(Arg_&& arg, Args_... args);
  std::string* mutable_file_path();
  PROTOBUF_NODISCARD std::string* release_file_path();
  void set_allocated_file_path(std::string* value);

  private:
  const std::string& _internal_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(
      const std::string& value);
  std::string* _internal_mutable_file_path();

  public:
  // bytes file_content = 2;
  bool has_file_content() const;
  void clear_file_content() ;
  const std::string& file_content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_file_content(Arg_&& arg, Args_... args);
  std::string* mutable_file_content();
  PROTOBUF_NODISCARD std::string* release_file_content();
  void set_allocated_file_content(std::string* value);

  private:
  const std::string& _internal_file_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_content(
      const std::string& value);
  std::string* _internal_mutable_file_content();

  public:
  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:whisper.WhisperRequest)
 private:
  class _Internal;
  void set_has_file_path();
  void set_has_file_content();
  inline bool has_data() const;
  inline void clear_has_data();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 0,
      49, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_WhisperRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WhisperRequest& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> passwords_;
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr file_path_;
      ::google::protobuf::internal::ArenaStringPtr file_content_;
    } data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5fwhisper_2eproto;
};
// -------------------------------------------------------------------

class Meta_MapStringEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          Meta_MapStringEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      Meta_MapStringEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  Meta_MapStringEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Meta_MapStringEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Meta_MapStringEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Meta_MapStringEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Meta_MapStringEntry_DoNotUse*>(
        &_Meta_MapStringEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      44, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_file_5fwhisper_2eproto;
};
// -------------------------------------------------------------------

class Meta_MapNumberEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          Meta_MapNumberEntry_DoNotUse, std::string, ::int64_t,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT64> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      Meta_MapNumberEntry_DoNotUse, std::string, ::int64_t,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64>;
  Meta_MapNumberEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Meta_MapNumberEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Meta_MapNumberEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Meta_MapNumberEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Meta_MapNumberEntry_DoNotUse*>(
        &_Meta_MapNumberEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      39, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_file_5fwhisper_2eproto;
};
// -------------------------------------------------------------------

class Meta_MapBoolEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          Meta_MapBoolEntry_DoNotUse, std::string, bool,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_BOOL> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      Meta_MapBoolEntry_DoNotUse, std::string, bool,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>;
  Meta_MapBoolEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Meta_MapBoolEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Meta_MapBoolEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Meta_MapBoolEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Meta_MapBoolEntry_DoNotUse*>(
        &_Meta_MapBoolEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      37, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_file_5fwhisper_2eproto;
};
// -------------------------------------------------------------------

class File final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:whisper.File) */ {
 public:
  inline File() : File(nullptr) {}
  ~File() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR File(
      ::google::protobuf::internal::ConstantInitialized);

  inline File(const File& from) : File(nullptr, from) {}
  inline File(File&& from) noexcept
      : File(nullptr, std::move(from)) {}
  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  inline File& operator=(File&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const File& default_instance() {
    return *internal_default_instance();
  }
  static inline const File* internal_default_instance() {
    return reinterpret_cast<const File*>(
        &_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(File& a, File& b) { a.Swap(&b); }
  inline void Swap(File* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(File* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  File* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<File>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const File& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const File& from) { File::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(File* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "whisper.File"; }

 protected:
  explicit File(::google::protobuf::Arena* arena);
  File(::google::protobuf::Arena* arena, const File& from);
  File(::google::protobuf::Arena* arena, File&& from) noexcept
      : File(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPathFieldNumber = 1,
    kNameFieldNumber = 2,
    kMimeTypeFieldNumber = 4,
    kExtensionFieldNumber = 5,
    kMd5FieldNumber = 6,
    kSha256FieldNumber = 7,
    kContentFieldNumber = 8,
    kSizeFieldNumber = 3,
  };
  // string path = 1;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string mime_type = 4;
  void clear_mime_type() ;
  const std::string& mime_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mime_type(Arg_&& arg, Args_... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* value);

  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(
      const std::string& value);
  std::string* _internal_mutable_mime_type();

  public:
  // string extension = 5;
  void clear_extension() ;
  const std::string& extension() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_extension(Arg_&& arg, Args_... args);
  std::string* mutable_extension();
  PROTOBUF_NODISCARD std::string* release_extension();
  void set_allocated_extension(std::string* value);

  private:
  const std::string& _internal_extension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extension(
      const std::string& value);
  std::string* _internal_mutable_extension();

  public:
  // string md5 = 6;
  void clear_md5() ;
  const std::string& md5() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_md5(Arg_&& arg, Args_... args);
  std::string* mutable_md5();
  PROTOBUF_NODISCARD std::string* release_md5();
  void set_allocated_md5(std::string* value);

  private:
  const std::string& _internal_md5() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_md5(
      const std::string& value);
  std::string* _internal_mutable_md5();

  public:
  // string sha256 = 7;
  void clear_sha256() ;
  const std::string& sha256() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sha256(Arg_&& arg, Args_... args);
  std::string* mutable_sha256();
  PROTOBUF_NODISCARD std::string* release_sha256();
  void set_allocated_sha256(std::string* value);

  private:
  const std::string& _internal_sha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sha256(
      const std::string& value);
  std::string* _internal_mutable_sha256();

  public:
  // optional bytes content = 8;
  bool has_content() const;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* value);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // int64 size = 3;
  void clear_size() ;
  ::int64_t size() const;
  void set_size(::int64_t value);

  private:
  ::int64_t _internal_size() const;
  void _internal_set_size(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:whisper.File)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 0,
      64, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_File_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const File& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr mime_type_;
    ::google::protobuf::internal::ArenaStringPtr extension_;
    ::google::protobuf::internal::ArenaStringPtr md5_;
    ::google::protobuf::internal::ArenaStringPtr sha256_;
    ::google::protobuf::internal::ArenaStringPtr content_;
    ::int64_t size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5fwhisper_2eproto;
};
// -------------------------------------------------------------------

class Data final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:whisper.Data) */ {
 public:
  inline Data() : Data(nullptr) {}
  ~Data() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Data(
      ::google::protobuf::internal::ConstantInitialized);

  inline Data(const Data& from) : Data(nullptr, from) {}
  inline Data(Data&& from) noexcept
      : Data(nullptr, std::move(from)) {}
  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline Data& operator=(Data&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Data& default_instance() {
    return *internal_default_instance();
  }
  static inline const Data* internal_default_instance() {
    return reinterpret_cast<const Data*>(
        &_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(Data& a, Data& b) { a.Swap(&b); }
  inline void Swap(Data* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Data* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Data* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Data>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Data& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Data& from) { Data::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Data* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "whisper.Data"; }

 protected:
  explicit Data(::google::protobuf::Arena* arena);
  Data(::google::protobuf::Arena* arena, const Data& from);
  Data(::google::protobuf::Arena* arena, Data&& from) noexcept
      : Data(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kContentFieldNumber = 2,
  };
  // string type = 1;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // bytes content = 2;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* value);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // @@protoc_insertion_point(class_scope:whisper.Data)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      25, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Data_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Data& from_msg);
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr content_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5fwhisper_2eproto;
};
// -------------------------------------------------------------------

class Meta final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:whisper.Meta) */ {
 public:
  inline Meta() : Meta(nullptr) {}
  ~Meta() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Meta(
      ::google::protobuf::internal::ConstantInitialized);

  inline Meta(const Meta& from) : Meta(nullptr, from) {}
  inline Meta(Meta&& from) noexcept
      : Meta(nullptr, std::move(from)) {}
  inline Meta& operator=(const Meta& from) {
    CopyFrom(from);
    return *this;
  }
  inline Meta& operator=(Meta&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Meta& default_instance() {
    return *internal_default_instance();
  }
  static inline const Meta* internal_default_instance() {
    return reinterpret_cast<const Meta*>(
        &_Meta_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Meta& a, Meta& b) { a.Swap(&b); }
  inline void Swap(Meta* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Meta* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Meta* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Meta>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Meta& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Meta& from) { Meta::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Meta* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "whisper.Meta"; }

 protected:
  explicit Meta(::google::protobuf::Arena* arena);
  Meta(::google::protobuf::Arena* arena, const Meta& from);
  Meta(::google::protobuf::Arena* arena, Meta&& from) noexcept
      : Meta(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMapStringFieldNumber = 1,
    kMapNumberFieldNumber = 2,
    kMapBoolFieldNumber = 3,
  };
  // map<string, string> map_string = 1;
  int map_string_size() const;
  private:
  int _internal_map_string_size() const;

  public:
  void clear_map_string() ;
  const ::google::protobuf::Map<std::string, std::string>& map_string() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_map_string();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_map_string() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_map_string();

  public:
  // map<string, int64> map_number = 2;
  int map_number_size() const;
  private:
  int _internal_map_number_size() const;

  public:
  void clear_map_number() ;
  const ::google::protobuf::Map<std::string, ::int64_t>& map_number() const;
  ::google::protobuf::Map<std::string, ::int64_t>* mutable_map_number();

  private:
  const ::google::protobuf::Map<std::string, ::int64_t>& _internal_map_number() const;
  ::google::protobuf::Map<std::string, ::int64_t>* _internal_mutable_map_number();

  public:
  // map<string, bool> map_bool = 3;
  int map_bool_size() const;
  private:
  int _internal_map_bool_size() const;

  public:
  void clear_map_bool() ;
  const ::google::protobuf::Map<std::string, bool>& map_bool() const;
  ::google::protobuf::Map<std::string, bool>* mutable_map_bool();

  private:
  const ::google::protobuf::Map<std::string, bool>& _internal_map_bool() const;
  ::google::protobuf::Map<std::string, bool>* _internal_mutable_map_bool();

  public:
  // @@protoc_insertion_point(class_scope:whisper.Meta)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      49, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Meta_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Meta& from_msg);
    ::google::protobuf::internal::MapField<Meta_MapStringEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        map_string_;
    ::google::protobuf::internal::MapField<Meta_MapNumberEntry_DoNotUse, std::string, ::int64_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT64>
        map_number_;
    ::google::protobuf::internal::MapField<Meta_MapBoolEntry_DoNotUse, std::string, bool,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>
        map_bool_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5fwhisper_2eproto;
};
// -------------------------------------------------------------------

class Node final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:whisper.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  ~Node() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Node(
      ::google::protobuf::internal::ConstantInitialized);

  inline Node(const Node& from) : Node(nullptr, from) {}
  inline Node(Node&& from) noexcept
      : Node(nullptr, std::move(from)) {}
  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node& default_instance() {
    return *internal_default_instance();
  }
  enum ContentCase {
    kFile = 4,
    kData = 5,
    CONTENT_NOT_SET = 0,
  };
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
        &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Node& a, Node& b) { a.Swap(&b); }
  inline void Swap(Node* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Node>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Node& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Node& from) { Node::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Node* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "whisper.Node"; }

 protected:
  explicit Node(::google::protobuf::Arena* arena);
  Node(::google::protobuf::Arena* arena, const Node& from);
  Node(::google::protobuf::Arena* arena, Node&& from) noexcept
      : Node(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChildrenFieldNumber = 3,
    kMetaFieldNumber = 6,
    kIdFieldNumber = 1,
    kParentIdFieldNumber = 2,
    kFileFieldNumber = 4,
    kDataFieldNumber = 5,
  };
  // repeated int64 children = 3;
  int children_size() const;
  private:
  int _internal_children_size() const;

  public:
  void clear_children() ;
  ::int64_t children(int index) const;
  void set_children(int index, ::int64_t value);
  void add_children(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& children() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_children();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_children() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_children();

  public:
  // .whisper.Meta meta = 6;
  bool has_meta() const;
  void clear_meta() ;
  const ::whisper::Meta& meta() const;
  PROTOBUF_NODISCARD ::whisper::Meta* release_meta();
  ::whisper::Meta* mutable_meta();
  void set_allocated_meta(::whisper::Meta* value);
  void unsafe_arena_set_allocated_meta(::whisper::Meta* value);
  ::whisper::Meta* unsafe_arena_release_meta();

  private:
  const ::whisper::Meta& _internal_meta() const;
  ::whisper::Meta* _internal_mutable_meta();

  public:
  // int64 id = 1;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // int64 parent_id = 2;
  void clear_parent_id() ;
  ::int64_t parent_id() const;
  void set_parent_id(::int64_t value);

  private:
  ::int64_t _internal_parent_id() const;
  void _internal_set_parent_id(::int64_t value);

  public:
  // .whisper.File file = 4;
  bool has_file() const;
  private:
  bool _internal_has_file() const;

  public:
  void clear_file() ;
  const ::whisper::File& file() const;
  PROTOBUF_NODISCARD ::whisper::File* release_file();
  ::whisper::File* mutable_file();
  void set_allocated_file(::whisper::File* value);
  void unsafe_arena_set_allocated_file(::whisper::File* value);
  ::whisper::File* unsafe_arena_release_file();

  private:
  const ::whisper::File& _internal_file() const;
  ::whisper::File* _internal_mutable_file();

  public:
  // .whisper.Data data = 5;
  bool has_data() const;
  private:
  bool _internal_has_data() const;

  public:
  void clear_data() ;
  const ::whisper::Data& data() const;
  PROTOBUF_NODISCARD ::whisper::Data* release_data();
  ::whisper::Data* mutable_data();
  void set_allocated_data(::whisper::Data* value);
  void unsafe_arena_set_allocated_data(::whisper::Data* value);
  ::whisper::Data* unsafe_arena_release_data();

  private:
  const ::whisper::Data& _internal_data() const;
  ::whisper::Data* _internal_mutable_data();

  public:
  void clear_content();
  ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:whisper.Node)
 private:
  class _Internal;
  void set_has_file();
  void set_has_data();
  inline bool has_content() const;
  inline void clear_has_content();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Node_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Node& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> children_;
    mutable ::google::protobuf::internal::CachedSize _children_cached_byte_size_;
    ::whisper::Meta* meta_;
    ::int64_t id_;
    ::int64_t parent_id_;
    union ContentUnion {
      constexpr ContentUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::whisper::File* file_;
      ::whisper::Data* data_;
    } content_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5fwhisper_2eproto;
};
// -------------------------------------------------------------------

class WhisperReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:whisper.WhisperReply) */ {
 public:
  inline WhisperReply() : WhisperReply(nullptr) {}
  ~WhisperReply() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WhisperReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline WhisperReply(const WhisperReply& from) : WhisperReply(nullptr, from) {}
  inline WhisperReply(WhisperReply&& from) noexcept
      : WhisperReply(nullptr, std::move(from)) {}
  inline WhisperReply& operator=(const WhisperReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline WhisperReply& operator=(WhisperReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WhisperReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const WhisperReply* internal_default_instance() {
    return reinterpret_cast<const WhisperReply*>(
        &_WhisperReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(WhisperReply& a, WhisperReply& b) { a.Swap(&b); }
  inline void Swap(WhisperReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WhisperReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WhisperReply* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<WhisperReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WhisperReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WhisperReply& from) { WhisperReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WhisperReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "whisper.WhisperReply"; }

 protected:
  explicit WhisperReply(::google::protobuf::Arena* arena);
  WhisperReply(::google::protobuf::Arena* arena, const WhisperReply& from);
  WhisperReply(::google::protobuf::Arena* arena, WhisperReply&& from) noexcept
      : WhisperReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTreeFieldNumber = 1,
  };
  // repeated .whisper.Node tree = 1;
  int tree_size() const;
  private:
  int _internal_tree_size() const;

  public:
  void clear_tree() ;
  ::whisper::Node* mutable_tree(int index);
  ::google::protobuf::RepeatedPtrField<::whisper::Node>* mutable_tree();

  private:
  const ::google::protobuf::RepeatedPtrField<::whisper::Node>& _internal_tree() const;
  ::google::protobuf::RepeatedPtrField<::whisper::Node>* _internal_mutable_tree();
  public:
  const ::whisper::Node& tree(int index) const;
  ::whisper::Node* add_tree();
  const ::google::protobuf::RepeatedPtrField<::whisper::Node>& tree() const;
  // @@protoc_insertion_point(class_scope:whisper.WhisperReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_WhisperReply_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WhisperReply& from_msg);
    ::google::protobuf::RepeatedPtrField< ::whisper::Node > tree_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_file_5fwhisper_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// WhisperRequest

// string file_path = 1;
inline bool WhisperRequest::has_file_path() const {
  return data_case() == kFilePath;
}
inline void WhisperRequest::set_has_file_path() {
  _impl_._oneof_case_[0] = kFilePath;
}
inline void WhisperRequest::clear_file_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() == kFilePath) {
    _impl_.data_.file_path_.Destroy();
    clear_has_data();
  }
}
inline const std::string& WhisperRequest::file_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:whisper.WhisperRequest.file_path)
  return _internal_file_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WhisperRequest::set_file_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() != kFilePath) {
    clear_data();

    set_has_file_path();
    _impl_.data_.file_path_.InitDefault();
  }
  _impl_.data_.file_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:whisper.WhisperRequest.file_path)
}
inline std::string* WhisperRequest::mutable_file_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_file_path();
  // @@protoc_insertion_point(field_mutable:whisper.WhisperRequest.file_path)
  return _s;
}
inline const std::string& WhisperRequest::_internal_file_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (data_case() != kFilePath) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.data_.file_path_.Get();
}
inline void WhisperRequest::_internal_set_file_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() != kFilePath) {
    clear_data();

    set_has_file_path();
    _impl_.data_.file_path_.InitDefault();
  }
  _impl_.data_.file_path_.Set(value, GetArena());
}
inline std::string* WhisperRequest::_internal_mutable_file_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() != kFilePath) {
    clear_data();

    set_has_file_path();
    _impl_.data_.file_path_.InitDefault();
  }
  return _impl_.data_.file_path_.Mutable( GetArena());
}
inline std::string* WhisperRequest::release_file_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:whisper.WhisperRequest.file_path)
  if (data_case() != kFilePath) {
    return nullptr;
  }
  clear_has_data();
  return _impl_.data_.file_path_.Release();
}
inline void WhisperRequest::set_allocated_file_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_data()) {
    clear_data();
  }
  if (value != nullptr) {
    set_has_file_path();
    _impl_.data_.file_path_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:whisper.WhisperRequest.file_path)
}

// bytes file_content = 2;
inline bool WhisperRequest::has_file_content() const {
  return data_case() == kFileContent;
}
inline void WhisperRequest::set_has_file_content() {
  _impl_._oneof_case_[0] = kFileContent;
}
inline void WhisperRequest::clear_file_content() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() == kFileContent) {
    _impl_.data_.file_content_.Destroy();
    clear_has_data();
  }
}
inline const std::string& WhisperRequest::file_content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:whisper.WhisperRequest.file_content)
  return _internal_file_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WhisperRequest::set_file_content(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() != kFileContent) {
    clear_data();

    set_has_file_content();
    _impl_.data_.file_content_.InitDefault();
  }
  _impl_.data_.file_content_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:whisper.WhisperRequest.file_content)
}
inline std::string* WhisperRequest::mutable_file_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_file_content();
  // @@protoc_insertion_point(field_mutable:whisper.WhisperRequest.file_content)
  return _s;
}
inline const std::string& WhisperRequest::_internal_file_content() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (data_case() != kFileContent) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.data_.file_content_.Get();
}
inline void WhisperRequest::_internal_set_file_content(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() != kFileContent) {
    clear_data();

    set_has_file_content();
    _impl_.data_.file_content_.InitDefault();
  }
  _impl_.data_.file_content_.Set(value, GetArena());
}
inline std::string* WhisperRequest::_internal_mutable_file_content() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() != kFileContent) {
    clear_data();

    set_has_file_content();
    _impl_.data_.file_content_.InitDefault();
  }
  return _impl_.data_.file_content_.Mutable( GetArena());
}
inline std::string* WhisperRequest::release_file_content() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:whisper.WhisperRequest.file_content)
  if (data_case() != kFileContent) {
    return nullptr;
  }
  clear_has_data();
  return _impl_.data_.file_content_.Release();
}
inline void WhisperRequest::set_allocated_file_content(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_data()) {
    clear_data();
  }
  if (value != nullptr) {
    set_has_file_content();
    _impl_.data_.file_content_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:whisper.WhisperRequest.file_content)
}

// repeated string passwords = 3;
inline int WhisperRequest::_internal_passwords_size() const {
  return _internal_passwords().size();
}
inline int WhisperRequest::passwords_size() const {
  return _internal_passwords_size();
}
inline void WhisperRequest::clear_passwords() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.passwords_.Clear();
}
inline std::string* WhisperRequest::add_passwords() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_passwords()->Add();
  // @@protoc_insertion_point(field_add_mutable:whisper.WhisperRequest.passwords)
  return _s;
}
inline const std::string& WhisperRequest::passwords(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:whisper.WhisperRequest.passwords)
  return _internal_passwords().Get(index);
}
inline std::string* WhisperRequest::mutable_passwords(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:whisper.WhisperRequest.passwords)
  return _internal_mutable_passwords()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void WhisperRequest::set_passwords(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_passwords()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:whisper.WhisperRequest.passwords)
}
template <typename Arg_, typename... Args_>
inline void WhisperRequest::add_passwords(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_passwords(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:whisper.WhisperRequest.passwords)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
WhisperRequest::passwords() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:whisper.WhisperRequest.passwords)
  return _internal_passwords();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
WhisperRequest::mutable_passwords() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:whisper.WhisperRequest.passwords)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_passwords();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
WhisperRequest::_internal_passwords() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.passwords_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
WhisperRequest::_internal_mutable_passwords() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.passwords_;
}

inline bool WhisperRequest::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void WhisperRequest::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline WhisperRequest::DataCase WhisperRequest::data_case() const {
  return WhisperRequest::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// WhisperReply

// repeated .whisper.Node tree = 1;
inline int WhisperReply::_internal_tree_size() const {
  return _internal_tree().size();
}
inline int WhisperReply::tree_size() const {
  return _internal_tree_size();
}
inline void WhisperReply::clear_tree() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tree_.Clear();
}
inline ::whisper::Node* WhisperReply::mutable_tree(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:whisper.WhisperReply.tree)
  return _internal_mutable_tree()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::whisper::Node>* WhisperReply::mutable_tree()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:whisper.WhisperReply.tree)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tree();
}
inline const ::whisper::Node& WhisperReply::tree(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:whisper.WhisperReply.tree)
  return _internal_tree().Get(index);
}
inline ::whisper::Node* WhisperReply::add_tree() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::whisper::Node* _add = _internal_mutable_tree()->Add();
  // @@protoc_insertion_point(field_add:whisper.WhisperReply.tree)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::whisper::Node>& WhisperReply::tree() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:whisper.WhisperReply.tree)
  return _internal_tree();
}
inline const ::google::protobuf::RepeatedPtrField<::whisper::Node>&
WhisperReply::_internal_tree() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tree_;
}
inline ::google::protobuf::RepeatedPtrField<::whisper::Node>*
WhisperReply::_internal_mutable_tree() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tree_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Meta

// map<string, string> map_string = 1;
inline int Meta::_internal_map_string_size() const {
  return _internal_map_string().size();
}
inline int Meta::map_string_size() const {
  return _internal_map_string_size();
}
inline void Meta::clear_map_string() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.map_string_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& Meta::_internal_map_string() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.map_string_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& Meta::map_string() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:whisper.Meta.map_string)
  return _internal_map_string();
}
inline ::google::protobuf::Map<std::string, std::string>* Meta::_internal_mutable_map_string() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.map_string_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* Meta::mutable_map_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:whisper.Meta.map_string)
  return _internal_mutable_map_string();
}

// map<string, int64> map_number = 2;
inline int Meta::_internal_map_number_size() const {
  return _internal_map_number().size();
}
inline int Meta::map_number_size() const {
  return _internal_map_number_size();
}
inline void Meta::clear_map_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.map_number_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int64_t>& Meta::_internal_map_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.map_number_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int64_t>& Meta::map_number() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:whisper.Meta.map_number)
  return _internal_map_number();
}
inline ::google::protobuf::Map<std::string, ::int64_t>* Meta::_internal_mutable_map_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.map_number_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int64_t>* Meta::mutable_map_number() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:whisper.Meta.map_number)
  return _internal_mutable_map_number();
}

// map<string, bool> map_bool = 3;
inline int Meta::_internal_map_bool_size() const {
  return _internal_map_bool().size();
}
inline int Meta::map_bool_size() const {
  return _internal_map_bool_size();
}
inline void Meta::clear_map_bool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.map_bool_.Clear();
}
inline const ::google::protobuf::Map<std::string, bool>& Meta::_internal_map_bool() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.map_bool_.GetMap();
}
inline const ::google::protobuf::Map<std::string, bool>& Meta::map_bool() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:whisper.Meta.map_bool)
  return _internal_map_bool();
}
inline ::google::protobuf::Map<std::string, bool>* Meta::_internal_mutable_map_bool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.map_bool_.MutableMap();
}
inline ::google::protobuf::Map<std::string, bool>* Meta::mutable_map_bool() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:whisper.Meta.map_bool)
  return _internal_mutable_map_bool();
}

// -------------------------------------------------------------------

// Node

// int64 id = 1;
inline void Node::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::int64_t{0};
}
inline ::int64_t Node::id() const {
  // @@protoc_insertion_point(field_get:whisper.Node.id)
  return _internal_id();
}
inline void Node::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:whisper.Node.id)
}
inline ::int64_t Node::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Node::_internal_set_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// int64 parent_id = 2;
inline void Node::clear_parent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_id_ = ::int64_t{0};
}
inline ::int64_t Node::parent_id() const {
  // @@protoc_insertion_point(field_get:whisper.Node.parent_id)
  return _internal_parent_id();
}
inline void Node::set_parent_id(::int64_t value) {
  _internal_set_parent_id(value);
  // @@protoc_insertion_point(field_set:whisper.Node.parent_id)
}
inline ::int64_t Node::_internal_parent_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_id_;
}
inline void Node::_internal_set_parent_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_id_ = value;
}

// repeated int64 children = 3;
inline int Node::_internal_children_size() const {
  return _internal_children().size();
}
inline int Node::children_size() const {
  return _internal_children_size();
}
inline void Node::clear_children() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.children_.Clear();
}
inline ::int64_t Node::children(int index) const {
  // @@protoc_insertion_point(field_get:whisper.Node.children)
  return _internal_children().Get(index);
}
inline void Node::set_children(int index, ::int64_t value) {
  _internal_mutable_children()->Set(index, value);
  // @@protoc_insertion_point(field_set:whisper.Node.children)
}
inline void Node::add_children(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_children()->Add(value);
  // @@protoc_insertion_point(field_add:whisper.Node.children)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Node::children() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:whisper.Node.children)
  return _internal_children();
}
inline ::google::protobuf::RepeatedField<::int64_t>* Node::mutable_children()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:whisper.Node.children)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_children();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
Node::_internal_children() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.children_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* Node::_internal_mutable_children() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.children_;
}

// .whisper.File file = 4;
inline bool Node::has_file() const {
  return content_case() == kFile;
}
inline bool Node::_internal_has_file() const {
  return content_case() == kFile;
}
inline void Node::set_has_file() {
  _impl_._oneof_case_[0] = kFile;
}
inline void Node::clear_file() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kFile) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.file_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.file_);
    }
    clear_has_content();
  }
}
inline ::whisper::File* Node::release_file() {
  // @@protoc_insertion_point(field_release:whisper.Node.file)
  if (content_case() == kFile) {
    clear_has_content();
    auto* temp = _impl_.content_.file_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::whisper::File& Node::_internal_file() const {
  return content_case() == kFile ? *_impl_.content_.file_ : reinterpret_cast<::whisper::File&>(::whisper::_File_default_instance_);
}
inline const ::whisper::File& Node::file() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:whisper.Node.file)
  return _internal_file();
}
inline ::whisper::File* Node::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:whisper.Node.file)
  if (content_case() == kFile) {
    clear_has_content();
    auto* temp = _impl_.content_.file_;
    _impl_.content_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Node::unsafe_arena_set_allocated_file(::whisper::File* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_file();
    _impl_.content_.file_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:whisper.Node.file)
}
inline ::whisper::File* Node::_internal_mutable_file() {
  if (content_case() != kFile) {
    clear_content();
    set_has_file();
    _impl_.content_.file_ =
        ::google::protobuf::Message::DefaultConstruct<::whisper::File>(GetArena());
  }
  return _impl_.content_.file_;
}
inline ::whisper::File* Node::mutable_file() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::whisper::File* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:whisper.Node.file)
  return _msg;
}

// .whisper.Data data = 5;
inline bool Node::has_data() const {
  return content_case() == kData;
}
inline bool Node::_internal_has_data() const {
  return content_case() == kData;
}
inline void Node::set_has_data() {
  _impl_._oneof_case_[0] = kData;
}
inline void Node::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (content_case() == kData) {
    if (GetArena() == nullptr) {
      delete _impl_.content_.data_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.content_.data_);
    }
    clear_has_content();
  }
}
inline ::whisper::Data* Node::release_data() {
  // @@protoc_insertion_point(field_release:whisper.Node.data)
  if (content_case() == kData) {
    clear_has_content();
    auto* temp = _impl_.content_.data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::whisper::Data& Node::_internal_data() const {
  return content_case() == kData ? *_impl_.content_.data_ : reinterpret_cast<::whisper::Data&>(::whisper::_Data_default_instance_);
}
inline const ::whisper::Data& Node::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:whisper.Node.data)
  return _internal_data();
}
inline ::whisper::Data* Node::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:whisper.Node.data)
  if (content_case() == kData) {
    clear_has_content();
    auto* temp = _impl_.content_.data_;
    _impl_.content_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Node::unsafe_arena_set_allocated_data(::whisper::Data* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_content();
  if (value) {
    set_has_data();
    _impl_.content_.data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:whisper.Node.data)
}
inline ::whisper::Data* Node::_internal_mutable_data() {
  if (content_case() != kData) {
    clear_content();
    set_has_data();
    _impl_.content_.data_ =
        ::google::protobuf::Message::DefaultConstruct<::whisper::Data>(GetArena());
  }
  return _impl_.content_.data_;
}
inline ::whisper::Data* Node::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::whisper::Data* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:whisper.Node.data)
  return _msg;
}

// .whisper.Meta meta = 6;
inline bool Node::has_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.meta_ != nullptr);
  return value;
}
inline void Node::clear_meta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.meta_ != nullptr) _impl_.meta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::whisper::Meta& Node::_internal_meta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::whisper::Meta* p = _impl_.meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::whisper::Meta&>(::whisper::_Meta_default_instance_);
}
inline const ::whisper::Meta& Node::meta() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:whisper.Node.meta)
  return _internal_meta();
}
inline void Node::unsafe_arena_set_allocated_meta(::whisper::Meta* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.meta_);
  }
  _impl_.meta_ = reinterpret_cast<::whisper::Meta*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:whisper.Node.meta)
}
inline ::whisper::Meta* Node::release_meta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::whisper::Meta* released = _impl_.meta_;
  _impl_.meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::whisper::Meta* Node::unsafe_arena_release_meta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:whisper.Node.meta)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::whisper::Meta* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
  return temp;
}
inline ::whisper::Meta* Node::_internal_mutable_meta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.meta_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::whisper::Meta>(GetArena());
    _impl_.meta_ = reinterpret_cast<::whisper::Meta*>(p);
  }
  return _impl_.meta_;
}
inline ::whisper::Meta* Node::mutable_meta() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::whisper::Meta* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:whisper.Node.meta)
  return _msg;
}
inline void Node::set_allocated_meta(::whisper::Meta* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.meta_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.meta_ = reinterpret_cast<::whisper::Meta*>(value);
  // @@protoc_insertion_point(field_set_allocated:whisper.Node.meta)
}

inline bool Node::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
inline void Node::clear_has_content() {
  _impl_._oneof_case_[0] = CONTENT_NOT_SET;
}
inline Node::ContentCase Node::content_case() const {
  return Node::ContentCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// File

// string path = 1;
inline void File::clear_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.ClearToEmpty();
}
inline const std::string& File::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:whisper.File.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void File::set_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:whisper.File.path)
}
inline std::string* File::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:whisper.File.path)
  return _s;
}
inline const std::string& File::_internal_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.path_.Get();
}
inline void File::_internal_set_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Set(value, GetArena());
}
inline std::string* File::_internal_mutable_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* File::release_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:whisper.File.path)
  return _impl_.path_.Release();
}
inline void File::set_allocated_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:whisper.File.path)
}

// string name = 2;
inline void File::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& File::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:whisper.File.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void File::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:whisper.File.name)
}
inline std::string* File::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:whisper.File.name)
  return _s;
}
inline const std::string& File::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void File::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* File::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* File::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:whisper.File.name)
  return _impl_.name_.Release();
}
inline void File::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:whisper.File.name)
}

// int64 size = 3;
inline void File::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = ::int64_t{0};
}
inline ::int64_t File::size() const {
  // @@protoc_insertion_point(field_get:whisper.File.size)
  return _internal_size();
}
inline void File::set_size(::int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:whisper.File.size)
}
inline ::int64_t File::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_;
}
inline void File::_internal_set_size(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// string mime_type = 4;
inline void File::clear_mime_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& File::mime_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:whisper.File.mime_type)
  return _internal_mime_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void File::set_mime_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mime_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:whisper.File.mime_type)
}
inline std::string* File::mutable_mime_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:whisper.File.mime_type)
  return _s;
}
inline const std::string& File::_internal_mime_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mime_type_.Get();
}
inline void File::_internal_set_mime_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mime_type_.Set(value, GetArena());
}
inline std::string* File::_internal_mutable_mime_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.mime_type_.Mutable( GetArena());
}
inline std::string* File::release_mime_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:whisper.File.mime_type)
  return _impl_.mime_type_.Release();
}
inline void File::set_allocated_mime_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mime_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mime_type_.IsDefault()) {
          _impl_.mime_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:whisper.File.mime_type)
}

// string extension = 5;
inline void File::clear_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.ClearToEmpty();
}
inline const std::string& File::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:whisper.File.extension)
  return _internal_extension();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void File::set_extension(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:whisper.File.extension)
}
inline std::string* File::mutable_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_extension();
  // @@protoc_insertion_point(field_mutable:whisper.File.extension)
  return _s;
}
inline const std::string& File::_internal_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extension_.Get();
}
inline void File::_internal_set_extension(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.Set(value, GetArena());
}
inline std::string* File::_internal_mutable_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.extension_.Mutable( GetArena());
}
inline std::string* File::release_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:whisper.File.extension)
  return _impl_.extension_.Release();
}
inline void File::set_allocated_extension(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.extension_.IsDefault()) {
          _impl_.extension_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:whisper.File.extension)
}

// string md5 = 6;
inline void File::clear_md5() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.md5_.ClearToEmpty();
}
inline const std::string& File::md5() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:whisper.File.md5)
  return _internal_md5();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void File::set_md5(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.md5_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:whisper.File.md5)
}
inline std::string* File::mutable_md5() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_md5();
  // @@protoc_insertion_point(field_mutable:whisper.File.md5)
  return _s;
}
inline const std::string& File::_internal_md5() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.md5_.Get();
}
inline void File::_internal_set_md5(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.md5_.Set(value, GetArena());
}
inline std::string* File::_internal_mutable_md5() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.md5_.Mutable( GetArena());
}
inline std::string* File::release_md5() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:whisper.File.md5)
  return _impl_.md5_.Release();
}
inline void File::set_allocated_md5(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.md5_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.md5_.IsDefault()) {
          _impl_.md5_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:whisper.File.md5)
}

// string sha256 = 7;
inline void File::clear_sha256() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sha256_.ClearToEmpty();
}
inline const std::string& File::sha256() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:whisper.File.sha256)
  return _internal_sha256();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void File::set_sha256(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sha256_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:whisper.File.sha256)
}
inline std::string* File::mutable_sha256() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sha256();
  // @@protoc_insertion_point(field_mutable:whisper.File.sha256)
  return _s;
}
inline const std::string& File::_internal_sha256() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sha256_.Get();
}
inline void File::_internal_set_sha256(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sha256_.Set(value, GetArena());
}
inline std::string* File::_internal_mutable_sha256() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sha256_.Mutable( GetArena());
}
inline std::string* File::release_sha256() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:whisper.File.sha256)
  return _impl_.sha256_.Release();
}
inline void File::set_allocated_sha256(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sha256_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sha256_.IsDefault()) {
          _impl_.sha256_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:whisper.File.sha256)
}

// optional bytes content = 8;
inline bool File::has_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void File::clear_content() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.content_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& File::content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:whisper.File.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void File::set_content(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.content_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:whisper.File.content)
}
inline std::string* File::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:whisper.File.content)
  return _s;
}
inline const std::string& File::_internal_content() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.content_.Get();
}
inline void File::_internal_set_content(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.content_.Set(value, GetArena());
}
inline std::string* File::_internal_mutable_content() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.content_.Mutable( GetArena());
}
inline std::string* File::release_content() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:whisper.File.content)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.content_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.content_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void File::set_allocated_content(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:whisper.File.content)
}

// -------------------------------------------------------------------

// Data

// string type = 1;
inline void Data::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Data::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:whisper.Data.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Data::set_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:whisper.Data.type)
}
inline std::string* Data::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:whisper.Data.type)
  return _s;
}
inline const std::string& Data::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void Data::_internal_set_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline std::string* Data::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* Data::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:whisper.Data.type)
  return _impl_.type_.Release();
}
inline void Data::set_allocated_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:whisper.Data.type)
}

// bytes content = 2;
inline void Data::clear_content() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Data::content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:whisper.Data.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Data::set_content(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.content_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:whisper.Data.content)
}
inline std::string* Data::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:whisper.Data.content)
  return _s;
}
inline const std::string& Data::_internal_content() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.content_.Get();
}
inline void Data::_internal_set_content(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.content_.Set(value, GetArena());
}
inline std::string* Data::_internal_mutable_content() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.content_.Mutable( GetArena());
}
inline std::string* Data::release_content() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:whisper.Data.content)
  return _impl_.content_.Release();
}
inline void Data::set_allocated_content(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:whisper.Data.content)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace whisper


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_file_5fwhisper_2eproto_2epb_2eh
